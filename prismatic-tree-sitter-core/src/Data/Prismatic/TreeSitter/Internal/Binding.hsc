{-# LANGUAGE CApiFFI #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}
-- Imports from #strict-import ^
#include <tree_sitter/api.h>
#include <bindings.dsl.h>

module Data.Prismatic.TreeSitter.Internal.Binding where
#strict_import

#capi_start_header "tree_sitter/api.h"

-- | The latest ABI version that is supported by the current version of the
-- library. When Languages are generated by the Tree-sitter CLI, they are
-- assigned an ABI version number that corresponds to the current CLI version.
-- The Tree-sitter library is generally backwards-compatible with languages
-- generated using older CLI versions, but is not forwards-compatible.
#num TREE_SITTER_LANGUAGE_VERSION

-- | The earliest ABI version that is supported by the current version of the
-- library.
#num TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION

-- * Section - Types

#integral_t TSStateId
#integral_t TSSymbol
#integral_t TSFieldId
#opaque_t TSLanguage 
#opaque_t TSParser 
#opaque_t TSTree 
#opaque_t TSQuery 
#opaque_t TSQueryCursor 
#opaque_t TSLookaheadIterator 

-- | This function signature reads one code point from the given string,
-- returning the number of bytes consumed. It should write the code point
-- to the `code_point` pointer, or write -1 if the input is invalid.
#callback_t DecodeFunction , ConstPtr Word8 -> Word32 -> Ptr Word32 -> IO Word32

#integral_t TSInputEncoding
#num TSInputEncodingUTF8
#num TSInputEncodingUTF16LE
#num TSInputEncodingUTF16BE
#num TSInputEncodingCustom

#integral_t TSSymbolType
#num TSSymbolTypeRegular
#num TSSymbolTypeAnonymous
#num TSSymbolTypeSupertype
#num TSSymbolTypeAuxiliary

#starttype TSPoint
#field row , Word32
#field column , Word32
#stoptype

#starttype TSRange
#field start_point , <TSPoint>
#field end_point , <TSPoint>
#field start_byte , Word32
#field end_byte , Word32
#stoptype


#starttype TSInput
#field payload , Ptr ()
#callback_t TSInput_read , Ptr () -> Word32 -> <TSPoint> -> Ptr Word32 -> IO (ConstPtr CChar)
#field read , <TSInput_read>
#field encoding , <TSInputEncoding>
#field decode , <DecodeFunction>
#stoptype

#starttype TSParseState
#field payload , Ptr () 
#field current_byte_offset , Word32
#field has_error , CBool
#stoptype

#starttype TSParseOptions
#field payload , Ptr ()
#callback_t TSParseOptions_progress_callback , Ptr <TSParseState> -> IO CBool
#field progress_callback , <TSParseOptions_progress_callback>
#stoptype

#integral_t TSLogType
#num TSLogTypeParse
#num TSLogTypeLex

#starttype TSLogger
#field payload , Ptr ()
#field log , FunPtr (Ptr () -> <TSLogType> -> ConstPtr CChar -> IO ())
#stoptype

#starttype TSInputEdit
#field start_byte , Word32
#field old_end_byte , Word32
#field new_end_byte , Word32
#field start_point , <TSPoint>
#field old_end_point , <TSPoint> 
#field new_end_point , <TSPoint>
#stoptype

#starttype TSNode
#array_field context , Word32
#field id , ConstPtr ()
#field tree , Ptr <TSTree>
#stoptype

#starttype TSTreeCursor
#field tree , ConstPtr ()
#field id , ConstPtr ()
#array_field context , Word32
#stoptype

#starttype TSQueryCapture
#field node , <TSNode>
#field index , Word32
#stoptype

#integral_t TSQuantifier
#num TSQuantifierZero
#num TSQuantifierZeroOrOne
#num TSQuantifierZeroOrMore
#num TSQuantifierOne
#num TSQuantifierOneOrMore

#starttype TSQueryMatch
#field id , Word32
#field pattern_index , Word16
#field capture_count , Word16
#field captures , ConstPtr ( <TSQueryCapture> )
#stoptype

#integral_t TSQueryPredicateStepType
#num TSQueryPredicateStepTypeDone
#num TSQueryPredicateStepTypeCapture
#num TSQueryPredicateStepTypeString

#starttype TSQueryPredicateStep
#field type , <TSQueryPredicateStepType>
#field value_id , Word32
#stoptype

-- ** TSQueryError
#integral_t TSQueryError
#num TSQueryErrorNone
#num TSQueryErrorSyntax
#num TSQueryErrorNodeType
#num TSQueryErrorField
#num TSQueryErrorCapture
#num TSQueryErrorStructure
#num TSQueryErrorLanguage

#starttype TSQueryCursorState
#field payload , Ptr ()
#field current_byte_offset , Word32
#stoptype

#starttype TSQueryCursorOptions
#field payload , Ptr ()
#field progress_callback , FunPtr( Ptr <TSQueryCursorState> -> IO CBool )
#stoptype

-- | The metadata associated with a language.
-- 
--  Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)
--  of the language. This version information should be used to signal if a given parser might
--  be incompatible with existing queries when upgrading between major versions, or minor versions
--  if it's in zerover.
#starttype TSLanguageMetadata
#field major_version , Word8
#field minor_version , Word8
#field patch_version , Word8
#stoptype

-- * Section - Parser

-- | Create a new parser.
#capi ts_parser_new , IO ( Ptr <TSParser> )
-- | Delete the parser, freeing all of the memory that it used.
#capi ts_parser_delete , Ptr <TSParser> -> IO ()

-- | Get the parser's current language.
#capi ts_parser_language , ConstPtr <TSParser> -> IO (ConstPtr <TSLanguage>)

-- | Set the language that the parser should use for parsing.
-- 
--  Returns a boolean indicating whether or not the language was successfully
--  assigned. True means assignment succeeded. False means there was a version
--  mismatch: the language was generated with an incompatible version of the
--  Tree-sitter CLI. Check the language's ABI version using [`ts_language_abi_version`]
--  and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and
--  [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants.
#capi ts_parser_set_language , Ptr <TSParser> -> \
  ConstPtr <TSLanguage> -> \
  IO CBool

-- | Set the ranges of text that the parser should include when parsing.
--
-- By default, the parser will always include entire documents. This function
-- allows you to parse only a *portion* of a document but still return a syntax
-- tree whose ranges match up with the document as a whole. You can also pass
-- multiple disjoint ranges.
--
-- The second and third parameters specify the location and length of an array
-- of ranges. The parser does *not* take ownership of these ranges; it copies
-- the data, so it doesn't matter how these ranges are allocated.
--
-- If `count` is zero, then the entire document will be parsed. Otherwise,
-- the given ranges must be ordered from earliest to latest in the document,
-- and they must not overlap. That is, the following must hold for all:
--
-- `i < count - 1`: `ranges[i].end_byte <= ranges[i + 1].start_byte`
--
-- If this requirement is not satisfied, the operation will fail, the ranges
-- will not be assigned, and this function will return `false`. On success,
-- this function returns `true`
#capi ts_parser_set_included_ranges , Ptr <TSParser> -> \
  ConstPtr <TSRange> -> \
  Word32 -> \
  IO CBool

-- | Get the ranges of text that the parser will include when parsing.
--
-- The returned pointer is owned by the parser. The caller should not free it
-- or write to it. The length of the array will be written to the given
-- `count` pointer.
#capi ts_parser_included_ranges , ConstPtr <TSParser> -> \
  Ptr Word32 -> \
  ConstPtr <TSRange>

-- | Use the parser to parse some source code and create a syntax tree.
--
-- If you are parsing this document for the first time, pass `NULL` for the
-- `old_tree` parameter. Otherwise, if you have already parsed an earlier
-- version of this document and the document has since been edited, pass the
-- previous syntax tree so that the unchanged parts of it can be reused.
-- This will save time and memory. For this to work correctly, you must have
-- already edited the old syntax tree using the [`ts_tree_edit`] function in a
-- way that exactly matches the source code changes.
--
-- The [`TSInput`] parameter lets you specify how to read the text. It has the
-- following three fields:
-- 1. [`read`]: A function to retrieve a chunk of text at a given byte offset
--    and (row, column) position. The function should return a pointer to the
--    text and write its length to the [`bytes_read`] pointer. The parser does
--    not take ownership of this buffer; it just borrows it until it has
--    finished reading it. The function should write a zero value to the
--    [`bytes_read`] pointer to indicate the end of the document.
-- 2. [`payload`]: An arbitrary pointer that will be passed to each invocation
--    of the [`read`] function.
-- 3. [`encoding`]: An indication of how the text is encoded. Either
--    `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.
--
-- This function returns a syntax tree on success, and `NULL` on failure. There
-- are four possible reasons for failure:
-- 1. The parser does not have a language assigned. Check for this using the [`ts_parser_language`] function.
-- 2. Parsing was cancelled due to a timeout that was set by an earlier call to
--    the [`ts_parser_set_timeout_micros`] function. You can resume parsing from
--    where the parser left out by calling [`ts_parser_parse`] again with the
--    same arguments. Or you can start parsing from scratch by first calling
--    [`ts_parser_reset`].
-- 3. Parsing was cancelled using a cancellation flag that was set by an
--    earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing
--    from where the parser left out by calling [`ts_parser_parse`] again with
--    the same arguments.
-- 4. Parsing was cancelled due to the progress callback returning true. This callback
--    is passed in [`ts_parser_parse_with_options`] inside the [`TSParseOptions`] struct.
--
-- [`read`]: TSInput::read
-- [`payload`]: TSInput::payload
-- [`encoding`]: TSInput::encoding
-- [`bytes_read`]: TSInput::read
#capi ts_parser_parse , Ptr <TSParser> -> \
  ConstPtr <TSTree> -> \
  <TSInput> -> \
 IO (Ptr <TSTree>)

-- | Use the parser to parse some source code and create a syntax tree, with some options.
--
-- See [`ts_parser_parse`] for more details.
--
-- See [`TSParseOptions`] for more details on the options.
#capi ts_parser_parse_with_options , Ptr <TSParser> -> \
  ConstPtr <TSTree> -> \
  <TSInput> -> \
  <TSParseOptions> -> \
  IO (Ptr <TSTree>)

-- -- | Use the parser to parse some source code stored in one contiguous buffer.
-- -- The first two parameters are the same as in the [`ts_parser_parse`] function
-- -- above. The second two parameters indicate the location of the buffer and its
-- -- length in bytes.
-- TSTree *ts_parser_parse_string(
--   TSParser *self,
--   const TSTree *old_tree,
--   const char *string,
--   uint32_t length
-- );
-- 
-- -- | Use the parser to parse some source code stored in one contiguous buffer with
-- -- a given encoding. The first four parameters work the same as in the
-- -- [`ts_parser_parse_string`] method above. The final parameter indicates whether
-- -- the text is encoded as UTF8 or UTF16.
-- TSTree *ts_parser_parse_string_encoding(
--   TSParser *self,
--   const TSTree *old_tree,
--   const char *string,
--   uint32_t length,
--   TSInputEncoding encoding
-- );
-- 
-- -- | Instruct the parser to start the next parse from the beginning.
-- --
-- -- If the parser previously failed because of a timeout or a cancellation, then
-- -- by default, it will resume where it left off on the next call to
-- -- [`ts_parser_parse`] or other parsing functions. If you don't want to resume,
-- -- and instead intend to use this parser to parse some other document, you must
-- -- call [`ts_parser_reset`] first.
-- void ts_parser_reset(TSParser *self);
-- 
-- -- | @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
-- --
-- -- Set the maximum duration in microseconds that parsing should be allowed to
-- -- take before halting.
-- --
-- -- If parsing takes longer than this, it will halt early, returning NULL.
-- -- See [`ts_parser_parse`] for more information.
-- void ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros);
-- 
-- 
-- -- | Set the logger that a parser should use during parsing.
-- --
-- -- The parser does not take ownership over the logger payload. If a logger was
-- -- previously assigned, the caller is responsible for releasing any memory
-- -- owned by the previous logger.
-- void ts_parser_set_logger(TSParser *self, TSLogger logger);
-- 
-- -- | Get the parser's current logger.
-- TSLogger ts_parser_logger(const TSParser *self);
-- 
-- -- | Set the file descriptor to which the parser should write debugging graphs
-- -- during parsing. The graphs are formatted in the DOT language. You may want
-- -- to pipe these graphs directly to a `dot(1)` process in order to generate
-- -- SVG output. You can turn off this logging by passing a negative number.
-- void ts_parser_print_dot_graphs(TSParser *self, int fd);

#capi_stop_header "tree_sitter/api.h"
